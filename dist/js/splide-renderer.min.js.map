{"version":3,"file":"splide-renderer.min.js","sources":["../../src/js/constants/directions.ts","../../src/js/components/Direction/Direction.ts","../../src/js/constants/project.ts","../../src/js/constants/classes.ts","../../src/js/constants/defaults.ts","../../src/js/constants/i18n.ts","../../src/js/utils/type/type.ts","../../src/js/utils/array/toArray/toArray.ts","../../src/js/utils/array/forEach/forEach.ts","../../src/js/utils/array/push/push.ts","../../src/js/utils/array/index.ts","../../src/js/utils/arrayLike/slice/slice.ts","../../src/js/utils/dom/matches/matches.ts","../../src/js/utils/dom/child/child.ts","../../src/js/utils/dom/children/children.ts","../../src/js/utils/object/forOwn/forOwn.ts","../../src/js/utils/object/assign/assign.ts","../../src/js/utils/object/merge/merge.ts","../../src/js/utils/dom/remove/remove.ts","../../src/js/utils/dom/unit/unit.ts","../../src/js/utils/error/assert/assert.ts","../../src/js/utils/math/math/math.ts","../../src/js/utils/string/camelToKebab/camelToKebab.ts","../../src/js/utils/string/uniqueId/uniqueId.ts","../../src/js/constructors/EventInterface/EventInterface.ts","../../src/js/utils/function/apply/apply.ts","../../src/js/constants/events.ts","../../src/js/renderer/constants/defaults.ts","../../src/js/renderer/Style/Style.ts","../../src/js/renderer/SplideRenderer/SplideRenderer.ts","../../src/js/utils/string/pad/pad.ts","../../src/js/utils/dom/queryAll/queryAll.ts","../../src/js/constants/types.ts","../../src/js/renderer/constants/classes.ts","../../src/js/components/Arrows/path.ts"],"sourcesContent":["/**\n * Enumerates slides from left to right.\n */\nexport const LTR = 'ltr';\n\n/**\n * Enumerates slides from right to left.\n */\nexport const RTL = 'rtl';\n\n/**\n * Enumerates slides in a col.\n */\nexport const TTB = 'ttb';\n","import { RTL, TTB } from '../../constants/directions';\nimport { Splide } from '../../core/Splide/Splide';\nimport { BaseComponent, Components, Options } from '../../types';\n\n\n/**\n * The interface for the Direction component.\n *\n * @since 3.0.0\n */\nexport interface DirectionComponent extends BaseComponent {\n  resolve( prop: string, axisOnly?: boolean ): string;\n  orient( value: number ): number;\n}\n\n/**\n * The translation map for directions.\n *\n * @since 3.0.0\n */\nexport const ORIENTATION_MAP = {\n  marginRight : [ 'marginBottom', 'marginLeft' ],\n  autoWidth   : [ 'autoHeight' ],\n  fixedWidth  : [ 'fixedHeight' ],\n  paddingLeft : [ 'paddingTop', 'paddingRight' ],\n  paddingRight: [ 'paddingBottom', 'paddingLeft' ],\n  width       : [ 'height' ],\n  left        : [ 'top', 'right' ],\n  right       : [ 'bottom', 'left' ],\n  x           : [ 'y' ],\n  X           : [ 'Y' ],\n  Y           : [ 'X' ],\n  ArrowLeft   : [ 'ArrowUp', 'ArrowRight' ],\n  ArrowRight  : [ 'ArrowDown', 'ArrowLeft' ],\n};\n\n/**\n * The component that absorbs the difference among directions.\n *\n * @since 3.0.0\n *\n * @param Splide     - A Splide instance.\n * @param Components - A collection of components.\n * @param options    - Options.\n *\n * @return A Direction component object.\n */\nexport function Direction( Splide: Splide, Components: Components, options: Options ): DirectionComponent {\n  /**\n   * Resolves the provided property name.\n   *\n   * @param prop     - A property name to translate.\n   * @param axisOnly - Optional. If `ture`, returns the same property for LTR and RTL.\n   */\n  function resolve( prop: string, axisOnly?: boolean ): string {\n    const { direction } = options;\n    const index = direction === RTL && ! axisOnly ? 1 : direction === TTB ? 0 : -1;\n    return ORIENTATION_MAP[ prop ][ index ] || prop;\n  }\n\n  /**\n   * Orients the value towards the current direction.\n   *\n   * @param value - A value to orient.\n   *\n   * @return The oriented value.\n   */\n  function orient( value: number ): number {\n    return value * ( options.direction === RTL ? 1 : -1 );\n  }\n\n  return {\n    resolve,\n    orient,\n  };\n}\n","/**\n * The project code.\n *\n * @since 3.0.0\n */\nexport const PROJECT_CODE = 'lbxsplide';\n\n/**\n * The data attribute prefix.\n *\n * @since 3.0.0\n */\nexport const DATA_ATTRIBUTE = `data-${ PROJECT_CODE }`;\n","import { PROJECT_CODE } from './project';\n\n\nexport const CLASS_ROOT            = PROJECT_CODE;\nexport const CLASS_SLIDER          = `${ PROJECT_CODE }__slider`;\nexport const CLASS_TRACK           = `${ PROJECT_CODE }__track`;\nexport const CLASS_LIST            = `${ PROJECT_CODE }__list`;\nexport const CLASS_SLIDE           = `${ PROJECT_CODE }__slide`;\nexport const CLASS_CLONE           = `${ CLASS_SLIDE }--clone`;\nexport const CLASS_CONTAINER       = `${ CLASS_SLIDE }__container`;\nexport const CLASS_ARROWS          = `${ PROJECT_CODE }__arrows`;\nexport const CLASS_ARROW           = `${ PROJECT_CODE }__arrow`;\nexport const CLASS_ARROW_PREV      = `${ CLASS_ARROW }--prev`;\nexport const CLASS_ARROW_NEXT      = `${ CLASS_ARROW }--next`;\nexport const CLASS_PAGINATION      = `${ PROJECT_CODE }__pagination`;\nexport const CLASS_PAGINATION_PAGE = `${ CLASS_PAGINATION }__page`;\nexport const CLASS_PROGRESS        = `${ PROJECT_CODE }__progress`;\nexport const CLASS_PROGRESS_BAR    = `${ CLASS_PROGRESS }__bar`;\nexport const CLASS_AUTOPLAY        = `${ PROJECT_CODE }__autoplay`;\nexport const CLASS_PLAY            = `${ PROJECT_CODE }__play`;\nexport const CLASS_PAUSE           = `${ PROJECT_CODE }__pause`;\nexport const CLASS_SPINNER         = `${ PROJECT_CODE }__spinner`;\nexport const CLASS_SR              = `${ PROJECT_CODE }__sr`;\nexport const CLASS_INITIALIZED     = 'is-initialized';\nexport const CLASS_ACTIVE          = 'is-active';\nexport const CLASS_PREV            = 'is-prev';\nexport const CLASS_NEXT            = 'is-next';\nexport const CLASS_VISIBLE         = 'is-visible';\nexport const CLASS_LOADING         = 'is-loading';\n\n/**\n * The array with all status classes.\n *\n * @since 3.0.0\n */\nexport const STATUS_CLASSES = [ CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING ];\n\n/**\n * The collection of classes for elements that Splide dynamically creates.\n *\n * @since 3.0.0\n */\nexport const CLASSES = {\n  slide     : CLASS_SLIDE,\n  clone     : CLASS_CLONE,\n  arrows    : CLASS_ARROWS,\n  arrow     : CLASS_ARROW,\n  prev      : CLASS_ARROW_PREV,\n  next      : CLASS_ARROW_NEXT,\n  pagination: CLASS_PAGINATION,\n  page      : CLASS_PAGINATION_PAGE,\n  spinner   : CLASS_SPINNER,\n};\n","import { Options } from '../types';\nimport { CLASSES } from './classes';\nimport { I18N } from './i18n';\n\n\n/**\n * The collection of default options.\n * Note that this collection does not contain all options.\n *\n * @since 3.0.0\n */\nexport const DEFAULTS: Options = {\n  type             : 'slide',\n  role             : 'region',\n  speed            : 400,\n  waitForTransition: true,\n  perPage          : 1,\n  cloneStatus      : true,\n  arrows           : true,\n  pagination       : true,\n  interval         : 5000,\n  pauseOnHover     : true,\n  pauseOnFocus     : true,\n  resetProgress    : true,\n  keyboard         : true,\n  easing           : 'cubic-bezier(0.25, 1, 0.5, 1)',\n  drag             : true,\n  direction        : 'ltr',\n  slideFocus       : true,\n  trimSpace        : true,\n  focusableNodes   : 'a, button, textarea, input, select, iframe',\n  classes          : CLASSES,\n  i18n             : I18N,\n};\n","/**\n * The collection of i18n strings.\n *\n * @since 3.0.0\n */\nexport const I18N = {\n  prev      : 'Previous slide',\n  next      : 'Next slide',\n  first     : 'Go to first slide',\n  last      : 'Go to last slide',\n  slideX    : 'Go to slide %s',\n  pageX     : 'Go to page %s',\n  play      : 'Start autoplay',\n  pause     : 'Pause autoplay',\n  carousel  : 'carousel',\n  slide     : 'slide',\n  slideLabel: '%s of %s', // [ slide number ] / [ slide size ]\n};\n","/**\n * Checks if the given subject is an object or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an object, or otherwise `false`.\n */\nexport function isObject( subject: unknown ): subject is object {\n  return ! isNull( subject ) && typeof subject === 'object';\n}\n\n/**\n * Checks if the given subject is an array or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an array, or otherwise `false`.\n */\nexport function isArray<T>( subject: unknown ): subject is T[] {\n  return Array.isArray( subject );\n}\n\n/**\n * Checks if the given subject is a function or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a function, or otherwise `false`.\n */\nexport function isFunction( subject: unknown ): subject is ( ...args: any[] ) => any {\n  return typeof subject === 'function';\n}\n\n/**\n * Checks if the given subject is a string or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a string, or otherwise `false`.\n */\nexport function isString( subject: unknown ): subject is string {\n  return typeof subject === 'string';\n}\n\n/**\n * Checks if the given subject is `undefined` or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is `undefined`, or otherwise `false`.\n */\nexport function isUndefined( subject: unknown ): subject is undefined {\n  return typeof subject === 'undefined';\n}\n\n/**\n * Checks if the given subject is `null` or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is `null`, or otherwise `false`.\n */\nexport function isNull( subject: unknown ): subject is null {\n  return subject === null;\n}\n\n/**\n * Checks if the given subject is an HTMLElement or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an HTMLElement instance, or otherwise `false`.\n */\nexport function isHTMLElement( subject: unknown ): subject is HTMLElement {\n  return subject instanceof HTMLElement;\n}\n\n/**\n * Checks if the given subject is an HTMLButtonElement or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an HTMLButtonElement, or otherwise `false`.\n */\nexport function isHTMLButtonElement( subject: unknown ): subject is HTMLButtonElement {\n  return subject instanceof HTMLButtonElement;\n}\n","import { isArray } from '../../type/type';\n\n\n/**\n * Push the provided value to an array if the value is not an array.\n *\n * @param value - A value to push.\n *\n * @return An array containing the value, or the value itself if it is already an array.\n */\nexport function toArray<T>( value: T | T[] ): T[] {\n  return isArray( value ) ? value : [ value ];\n}\n","import { toArray } from '../toArray/toArray';\n\n\n/**\n * The extended `Array#forEach` method that accepts a single value as an argument.\n *\n * @param values   - A value or values to iterate over.\n * @param iteratee - An iteratee function.\n */\nexport function forEach<T>( values: T | T[], iteratee: ( value: T, index: number, array: T[] ) => void ): void {\n  toArray( values ).forEach( iteratee );\n}\n","import { toArray } from '../toArray/toArray';\n\n\n/**\n * Extended `Array#push()` that accepts an item or an array with items.\n *\n * @param array - An array to push items.\n * @param items - An item or items to push.\n *\n * @return A provided array itself.\n */\nexport function push<T>( array: T[], items: T | T[] ): T[] {\n  array.push( ...toArray( items ) );\n  return array;\n}\n","export { empty }    from './empty/empty';\nexport { forEach }  from './forEach/forEach';\nexport { includes } from './includes/includes';\nexport { push }     from './push/push';\nexport { toArray }  from './toArray/toArray';\n\nexport const arrayProto = Array.prototype;\n","import { arrayProto } from '../../array';\n\n\n/**\n * The slice method for an array-like object.\n *\n * @param arrayLike - An array-like object.\n * @param start     - Optional. A start index.\n * @param end       - Optional. A end index.\n *\n * @return An array with sliced elements.\n */\nexport function slice<T>( arrayLike: ArrayLike<T>, start?: number, end?: number ): T[] {\n  return arrayProto.slice.call( arrayLike, start, end );\n}\n","import { isHTMLElement } from '../../type/type';\n\n\n/**\n * Checks if the element can be selected by the provided selector or not.\n *\n * @param elm      - An element to check.\n * @param selector - A selector to test.\n *\n * @return `true` if the selector matches the element, or otherwise `false`.\n */\nexport function matches( elm: Element | EventTarget, selector: string ): boolean {\n  return isHTMLElement( elm ) && ( elm[ 'msMatchesSelector' ] || elm.matches ).call( elm, selector );\n}\n","import { children } from '../children/children';\n\n\n/**\n * Returns a child element that matches the specified tag or class name.\n *\n * @param parent   - A parent element.\n * @param selector - A selector to filter children.\n *\n * @return A matched child element if available, or otherwise `undefined`.\n */\nexport function child<E extends HTMLElement>( parent: HTMLElement, selector?: string ): E | undefined {\n  return selector ? children<E>( parent, selector )[ 0 ] : parent.firstElementChild as E;\n}\n","import { slice } from '../../arrayLike';\nimport { matches } from '../matches/matches';\n\n\n/**\n * Finds children that has the specified tag or class name.\n *\n * @param parent   - A parent element.\n * @param selector - A selector to filter children.\n *\n * @return An array with filtered children.\n */\nexport function children<E extends HTMLElement>( parent: HTMLElement, selector: string ): E[] {\n  return parent ? slice( parent.children ).filter( child => matches( child, selector ) ) as E[] : [];\n}\n","/**\n * Iterates over the provided object by own enumerable keys with calling the iteratee function.\n *\n * @param object   - An object to iterate over.\n * @param iteratee - An iteratee function that takes the value and key as arguments.\n * @param right    - If `true`, the method iterates over the object from the end like `forEachRight()`.\n *\n * @return A provided object itself.\n */\nexport function forOwn<T extends object>(\n  object: T,\n  iteratee: ( value: T[ keyof T ], key: string ) => boolean | void,\n  right?: boolean\n): T {\n  if ( object ) {\n    let keys = Object.keys( object );\n    keys = right ? keys.reverse() : keys;\n\n    for ( let i = 0; i < keys.length; i++ ) {\n      const key = keys[ i ];\n\n      if ( key !== '__proto__' ) {\n        if ( iteratee( object[ key ], key ) === false ) {\n          break;\n        }\n      }\n    }\n  }\n\n  return object;\n}\n","import { slice } from '../../arrayLike';\nimport { forOwn } from '../forOwn/forOwn';\n\n\n/**\n * Assign U to T.\n *\n * @typeParam T - An object to assign to.\n * @typeParam U - An object to assign.\n *\n * @return An assigned object type.\n */\nexport type Assign<T, U> = Omit<T, keyof U> & U;\n\nexport function assign<T extends object>( object: T ): T;\n\n// There is a way to type arguments recursively, but these fixed definitions are enough for this project.\nexport function assign<T extends object, U extends object>( object: T, source: U ): Assign<T, U>;\n\nexport function assign<T extends object, U1 extends object, U2 extends object>(\n  object: T, source1: U1, source2: U2\n): Assign<Assign<T, U1>, U2>;\n\nexport function assign<T extends object, U1 extends object, U2 extends object, U3 extends object>(\n  object: T, source1: U1, source2: U2, source3: U3\n): Assign<Assign<Assign<T, U1>, U2>, U3>;\n\n/**\n * Assigns all own enumerable properties of all source objects to the provided object.\n * `undefined` in source objects will be skipped.\n *\n * @param object - An object to assign properties to.\n *\n * @return An object assigned properties of the sources to.\n */\nexport function assign<T extends object>( object: T ): any {\n  // eslint-disable-next-line prefer-rest-params, prefer-spread\n  slice( arguments, 1 ).forEach( source => {\n    forOwn( source, ( value, key ) => {\n      object[ key ] = source[ key ];\n    } );\n  } );\n\n  return object;\n}\n","import { Cast } from '../../../types';\nimport { isArray, isObject } from '../../type/type';\nimport { forOwn } from '../forOwn/forOwn';\n\n\n/**\n * Merges U to T.\n *\n * @typeParam T - An object to merge U into.\n * @typeParam U - An object to merge properties from.\n *\n * @return A merged object type.\n */\nexport type Merge<T extends object, U extends object> = Omit<T, keyof U> & {\n  [ K in ( keyof T & keyof U ) ]: U[ K ] extends object\n    ? U[ K ] extends any[]\n      ? T[ K ] extends any[]\n        ? Array<T[ K ][ number ] | U[ K ][ number ]>\n        : U[ K ]\n      : T[ K ] extends object\n        ? Merge<T[ K ], U[ K ]> extends infer A ? Cast<A, object> : never\n        : U[ K ]\n    : U[ K ];\n} & Omit<U, keyof T>;\n\n/**\n * Recursively merges source properties to the object.\n * Be aware that this method does not merge arrays. They are just duplicated by `slice()`.\n *\n * @param object - An object to merge properties to.\n * @param source - A source object to merge properties from.\n *\n * @return A new object with merged properties.\n */\nexport function merge<T extends object, U extends object>( object: T, source: U ): Merge<T, U> {\n  forOwn( source, ( value, key ) => {\n    if ( isArray( value ) ) {\n      object[ key ] = value.slice();\n    } else if ( isObject( value ) ) {\n      object[ key ] = merge( isObject( object[ key ] ) ? object[ key ] : {}, value );\n    } else {\n      object[ key ] = value;\n    }\n  } );\n\n  return object as Merge<T, U>;\n}\n","import { forEach } from '../../array';\n\n\n/**\n * Removes the provided node from its parent.\n *\n * @param nodes - A node or nodes to remove.\n */\nexport function remove( nodes: Node | Node[] ): void {\n  forEach( nodes, node => {\n    if ( node && node.parentNode ) {\n      node.parentNode.removeChild( node );\n    }\n  } );\n}\n","import { isString } from '../../type/type';\n\n\n/**\n * Appends `px` to the provided number.\n * If the value is already string, just returns it.\n *\n * @param value - A value to append `px` to.\n *\n * @return A string with the CSS unit.\n */\nexport function unit( value: number | string ): string {\n  return isString( value ) ? value : value ? `${ value }px` : '';\n}\n","import { PROJECT_CODE } from '../../../constants/project';\n\n\n/**\n * Throws an error if the provided condition is falsy.\n *\n * @param condition - If falsy, an error is thrown.\n * @param message   - Optional. A message to display.\n */\nexport function assert( condition: any, message?: string ): void {\n  if ( ! condition ) {\n    throw new Error( `[${ PROJECT_CODE }] ${ message || '' }` );\n  }\n}\n","export const { min, max, floor, ceil, abs } = Math;\n","/**\n * Converts the provided string in the camel case to the kebab case.\n *\n * @param string - A string to convert.\n */\nexport function camelToKebab( string: string ): string {\n  return string.replace( /([a-z0-9])([A-Z])/g, '$1-$2' ).toLowerCase();\n}\n","import { pad } from '../pad/pad';\n\n\n/**\n * Stores unique IDs.\n *\n * @since 3.0.0\n */\nconst ids: Record<string, number> = {};\n\n/**\n * Returns a sequential unique ID as \"{ prefix }-{ number }\".\n *\n * @param prefix - A prefix for the ID.\n */\nexport function uniqueId( prefix: string ): string {\n  return `${ prefix }${ pad( ( ids[ prefix ] = ( ids[ prefix ] || 0 ) + 1 ) ) }`;\n}\n","import { EVENT_DESTROY } from '../../constants/events';\nimport { Splide } from '../../core/Splide/Splide';\nimport { AnyFunction, EventMap } from '../../types';\nimport { apply, forEach } from '../../utils';\nimport { EventBusCallback } from '../EventBus/EventBus';\n\n\n/**\n * The interface for the EventInterface object.\n *\n * @since 3.0.0\n */\nexport interface EventInterfaceObject {\n  on<K extends keyof EventMap>( event: K, callback: EventMap[ K ], priority?: number ): void;\n  on( events: string | string[], callback: EventBusCallback, priority?: number ): void;\n  off<K extends keyof EventMap>( events: K | K[] | string | string[] ): void;\n  emit<K extends keyof EventMap>( event: K, ...args: Parameters<EventMap[ K ]> ): void\n  emit( event: string, ...args: any[] ): void;\n  bind(\n    target: Element | Window | Document | Array<Element | Window | Document>,\n    events: string,\n    callback: AnyFunction,\n    options?: AddEventListenerOptions\n  ): void\n  unbind(\n    target: Element | Window | Document | Array<Element | Window | Document>,\n    events: string,\n    callback?: AnyFunction,\n  ): void;\n  destroy(): void;\n}\n\n/**\n * The type for event targets.\n *\n * @since 3.0.0\n */\ntype EventTarget = Element | Window | Document;\n\n/**\n * The function that provides interface for internal and native events.\n *\n * @since 3.0.0\n *\n * @param Splide - A Splide instance.\n *\n * @return A collection of interface functions.\n */\nexport function EventInterface( Splide: Splide ): EventInterfaceObject {\n  /**\n   * Holds the event object.\n   */\n  const { event } = Splide;\n\n  /**\n   * The key for events.\n   */\n  const key = {};\n\n  /**\n   * Stores all handlers that listen to native events.\n   */\n  let listeners: [ EventTarget, string, AnyFunction, AddEventListenerOptions? ][] = [];\n\n  /**\n   * Registers an event handler with an unique key.\n   * It can only be removed by `off()` method below.\n   *\n   * @param events   - An event name or names separated by spaces. Use a dot(.) to add a namespace.\n   * @param callback - A callback function to register.\n   * @param priority - Optional. A priority number for the order in which the callbacks are invoked.\n   *                   Lower numbers correspond with earlier execution. The default value is 10.\n   */\n  function on( events: string | string[], callback: EventBusCallback, priority?: number ): void {\n    event.on( events, callback, key, priority );\n  }\n\n  /**\n   * Removes event handlers registered by `on()`.\n   *\n   * @param events - An event name or names separated by spaces. Use a dot(.) to add a namespace.\n   */\n  function off( events: string | string[] ): void {\n    event.off( events, key );\n  }\n\n  /**\n   * Listens to native events.\n   * Splide#destory() will remove all registered listeners.\n   *\n   * @param targets  - A target element, the window object or the document object.\n   * @param events   - An event or events to listen to.\n   * @param callback - A callback function.\n   * @param options  - Optional. The options to pass to the `addEventListener` function.\n   */\n  function bind(\n    targets: EventTarget | EventTarget[],\n    events: string,\n    callback: AnyFunction,\n    options?: AddEventListenerOptions\n  ): void {\n    forEachEvent( targets, events, ( target, event ) => {\n      listeners.push( [ target, event, callback, options ] );\n      target.addEventListener( event, callback, options );\n    } );\n  }\n\n  /**\n   * Removes the event handler.\n   *\n   * @param targets  - A target element, the window object or the document object.\n   * @param events   - An event name or names to remove.\n   * @param callback - Optional. Specify the callback to remove.\n   */\n  function unbind( targets: EventTarget | EventTarget[], events: string, callback?: AnyFunction ): void {\n    forEachEvent( targets, events, ( target, event ) => {\n      listeners = listeners.filter( listener => {\n        if ( listener[ 0 ] === target && listener[ 1 ] === event && ( ! callback || listener[ 2 ] === callback ) ) {\n          target.removeEventListener( event, listener[ 2 ], listener[ 3 ] );\n          return false;\n        }\n\n        return true;\n      } );\n    } );\n  }\n\n  /**\n   * Iterates over each target and event.\n   *\n   * @param targets  - A target element, the window object or the document object.\n   * @param events   - An event name or names.\n   * @param iteratee - An iteratee function.\n   */\n  function forEachEvent(\n    targets: EventTarget | EventTarget[],\n    events: string,\n    iteratee: ( target: EventTarget, event: string ) => void\n  ): void {\n    forEach( targets, target => {\n      if ( target ) {\n        events.split( ' ' ).forEach( apply( iteratee, target ) );\n      }\n    } );\n  }\n\n  /**\n   * Removes all listeners.\n   */\n  function destroy(): void {\n    listeners = listeners.filter( data => unbind( data[ 0 ], data[ 1 ] ) );\n    event.offBy( key );\n  }\n\n  /**\n   * Invokes destroy when the slider is destroyed.\n   */\n  event.on( EVENT_DESTROY, destroy, key );\n\n  return {\n    on,\n    off,\n    emit: event.emit,\n    bind,\n    unbind,\n    destroy,\n  };\n}\n","import { AnyFunction, ShiftN } from '../../../types';\nimport { slice } from '../../arrayLike';\n\n\n/**\n * Create a function where provided arguments are bound.\n * `this` parameter will be always null.\n *\n * @param func - A function.\n * @param args - Arguments to bind to the function.\n *\n * @return A function where arguments are bound.\n */\nexport function apply<F extends AnyFunction, A extends any[]>(\n  func: F,\n  ...args: A\n): ( ...args: ShiftN<Parameters<F>, A[\"length\"]> ) => ReturnType<F>;\n\n/**\n * Create a function where provided arguments are bound.\n * `this` parameter will be always null.\n *\n * @param func - A function.\n */\nexport function apply( func: AnyFunction ): any {\n  // eslint-disable-next-line prefer-rest-params, prefer-spread\n  return func.bind( null, ...slice( arguments, 1 ) );\n}\n","export const EVENT_MOUNTED            = 'mounted';\nexport const EVENT_READY              = 'ready';\nexport const EVENT_MOVE               = 'move';\nexport const EVENT_MOVED              = 'moved';\nexport const EVENT_SHIFTED            = 'shifted';\nexport const EVENT_CLICK              = 'click';\nexport const EVENT_ACTIVE             = 'active';\nexport const EVENT_INACTIVE           = 'inactive';\nexport const EVENT_VISIBLE            = 'visible';\nexport const EVENT_HIDDEN             = 'hidden';\nexport const EVENT_SLIDE_KEYDOWN      = 'slide:keydown';\nexport const EVENT_REFRESH            = 'refresh';\nexport const EVENT_UPDATED            = 'updated';\nexport const EVENT_RESIZE             = 'resize';\nexport const EVENT_RESIZED            = 'resized';\nexport const EVENT_REPOSITIONED       = 'repositioned';\nexport const EVENT_DRAG               = 'drag';\nexport const EVENT_DRAGGING           = 'dragging';\nexport const EVENT_DRAGGED            = 'dragged';\nexport const EVENT_SCROLL             = 'scroll';\nexport const EVENT_SCROLLED           = 'scrolled';\nexport const EVENT_DESTROY            = 'destroy';\nexport const EVENT_ARROWS_MOUNTED     = 'arrows:mounted';\nexport const EVENT_ARROWS_UPDATED     = 'arrows:updated';\nexport const EVENT_PAGINATION_MOUNTED = 'pagination:mounted';\nexport const EVENT_PAGINATION_UPDATED = 'pagination:updated';\nexport const EVENT_NAVIGATION_MOUNTED = 'navigation:mounted';\nexport const EVENT_AUTOPLAY_PLAY      = 'autoplay:play';\nexport const EVENT_AUTOPLAY_PLAYING   = 'autoplay:playing';\nexport const EVENT_AUTOPLAY_PAUSE     = 'autoplay:pause';\nexport const EVENT_LAZYLOAD_LOADED    = 'lazyload:loaded';\n\n","import { RendererConfig } from '../types/types';\n\n\n/**\n * Default options for generating static HTML.\n *\n * @since 3.0.0\n */\nexport const RENDERER_DEFAULT_CONFIG: RendererConfig = {\n  listTag : 'ul',\n  slideTag: 'li',\n};\n","import { Options } from '../../types';\nimport { forOwn } from '../../utils';\n\n\ninterface Styles {\n  [ breakpoint: string ]: {\n    [ selector: string ]: Record<string, string | number>\n  };\n}\n\n/**\n * The class for generating styles as a string.\n *\n * @since 3.0.0\n */\nexport class Style {\n  /**\n   * The collection of registered styles categorized by each breakpoint.\n   */\n  private readonly styles: Styles = {};\n\n  /**\n   * The ID of the slider.\n   */\n  private readonly id: string;\n\n  /**\n   * Holds options.\n   */\n  private readonly options: Options;\n\n  /**\n   * The Style constructor.\n   *\n   * @param id      - A slider ID.\n   * @param options - Options.\n   */\n  constructor( id: string, options: Options ) {\n    this.id      = id;\n    this.options = options;\n  }\n\n  /**\n   * Registers a CSS rule.\n   *\n   * @param selector - A selector.\n   * @param prop\n   * @param value\n   * @param breakpoint\n   */\n  rule( selector: string, prop: string, value: string | number, breakpoint?: string ): void {\n    breakpoint = breakpoint || 'default';\n    const selectors = ( this.styles[ breakpoint ] = this.styles[ breakpoint ] || {} );\n    const styles    = ( selectors[ selector ] = selectors[ selector ] || {} );\n    styles[ prop ] = value;\n  }\n\n  /**\n   * Builds styles as a single string.\n   *\n   * @return Built styles.\n   */\n  build(): string {\n    let css = '';\n\n    if ( this.styles.default ) {\n      css += this.buildSelectors( this.styles.default );\n    }\n\n    Object.keys( this.styles )\n      .sort( ( n, m ) => this.options.mediaQuery === 'min' ? +n - +m : +m - +n )\n      .forEach( breakpoint => {\n        if ( breakpoint !== 'default' ) {\n          css += `@media screen and (max-width: ${ breakpoint }px) {`;\n          css += this.buildSelectors( this.styles[ breakpoint ] );\n          css += `}`;\n        }\n      } );\n\n    return css;\n  }\n\n  /**\n   * Builds styles for each breakpoint.\n   *\n   * @param selectors - An object with styles.\n   *\n   * @return Built styles.\n   */\n  private buildSelectors( selectors: Record<string, Record<string, string | number>> ): string {\n    let css = '';\n\n    forOwn( selectors, ( styles, selector ) => {\n      selector = `#${ this.id } ${ selector }`.trim();\n      css += `${ selector } {`;\n\n      forOwn( styles, ( value, prop ) => {\n        if ( value || value === 0 ) {\n          css += `${ prop }: ${ value };`;\n        }\n      } );\n\n      css += '}';\n    } );\n\n    return css;\n  }\n}\n","import { PATH, SIZE, XML_NAME_SPACE } from '../../components/Arrows/path';\nimport { Direction, DirectionComponent } from '../../components/Direction/Direction';\nimport { CLASS_ACTIVE, CLASS_CLONE, CLASS_LIST, CLASS_ROOT, CLASS_SLIDE, CLASS_TRACK } from '../../constants/classes';\nimport { DEFAULTS } from '../../constants/defaults';\nimport { TTB } from '../../constants/directions';\nimport { EVENT_MOUNTED } from '../../constants/events';\nimport { LOOP, SLIDE } from '../../constants/types';\nimport { EventInterface } from '../../constructors';\nimport { Splide } from '../../core/Splide/Splide';\nimport { Options } from '../../types';\nimport {\n  assert,\n  assign,\n  camelToKebab,\n  child,\n  forOwn,\n  isObject,\n  isString,\n  max,\n  merge,\n  push,\n  queryAll,\n  remove,\n  uniqueId,\n  unit,\n} from '../../utils';\nimport { CLASS_RENDERED } from '../constants/classes';\nimport { RENDERER_DEFAULT_CONFIG } from '../constants/defaults';\nimport { Style } from '../Style/Style';\nimport { RendererConfig, SlideContent } from '../types/types';\n\n\n/**\n * The class to generate static HTML of the slider for the first view.\n *\n * @since 3.0.0\n */\nexport class SplideRenderer {\n  /**\n   * Removes a style element and clones.\n   *\n   * @param splide - A Splide instance.\n   */\n  static clean( splide: Splide ): void {\n    const { on } = EventInterface( splide );\n    const { root } = splide;\n    const clones = queryAll( root, `.${ CLASS_CLONE }` );\n\n    on( EVENT_MOUNTED, () => {\n      remove( child( root, 'style' ) );\n    } );\n\n    remove( clones );\n  }\n\n  /**\n   * Holds slide contents.\n   */\n  private readonly contents: string[] | SlideContent[];\n\n  /**\n   * Stores data of slides.\n   */\n  private readonly slides: SlideContent[] = [];\n\n  /**\n   * The Direction component.\n   */\n  private readonly Direction: DirectionComponent;\n\n  /**\n   * Holds the Style instance.\n   */\n  private readonly Style: Style;\n\n  /**\n   * Holds options.\n   */\n  private readonly options: Options = {};\n\n  /**\n   * Holds options for this instance.\n   */\n  private readonly config: RendererConfig;\n\n  /**\n   * The slider ID.\n   */\n  private readonly id: string;\n\n  /**\n   * An array with options for each breakpoint.\n   */\n  private readonly breakpoints: [ string, Options ][] = [];\n\n  /**\n   * The SplideRenderer constructor.\n   *\n   * @param contents - An array with slide contents. Each item must be an HTML or a plain text.\n   * @param options  - Optional. Slider options.\n   * @param config   - Static default options.\n   * @param defaults - Default options for the slider. Pass `Splide.defaults` if you are using it.\n   */\n  constructor( contents: string[] | SlideContent[], options?: Options, config?: RendererConfig, defaults?: Options ) {\n    merge( DEFAULTS, defaults || {} );\n    merge( merge( this.options, DEFAULTS ), options || {} );\n\n    this.contents  = contents;\n    this.config    = assign( {}, RENDERER_DEFAULT_CONFIG, config || {} );\n    this.id        = this.config.id || uniqueId( 'splide' );\n    this.Style     = new Style( this.id, this.options );\n    this.Direction = Direction( null, null, this.options );\n\n    assert( this.contents.length, 'Provide at least 1 content.' );\n\n    this.init();\n  }\n\n  /**\n   * Initializes the instance.\n   */\n  private init(): void {\n    this.parseBreakpoints();\n    this.initSlides();\n    this.registerRootStyles();\n    this.registerTrackStyles();\n    this.registerSlideStyles();\n    this.registerListStyles();\n  }\n\n  /**\n   * Initializes slides.\n   */\n  private initSlides(): void {\n    push( this.slides, this.contents.map( ( content, index ) => {\n      content = isString( content ) ? { html: content } : content;\n      content.styles = content.styles || {};\n      content.attrs  = content.attrs || {};\n\n      this.cover( content );\n\n      const classes = `${ this.options.classes.slide } ${ index === 0 ? CLASS_ACTIVE : '' }`;\n\n      assign( content.attrs, {\n        class: `${ classes } ${ content.attrs.class || '' }`.trim(),\n        style: this.buildStyles( content.styles ),\n      } );\n\n      return content;\n    } ) );\n\n    if ( this.isLoop() ) {\n      this.generateClones( this.slides );\n    }\n  }\n\n  /**\n   * Registers styles for the root element.\n   */\n  private registerRootStyles(): void {\n    this.breakpoints.forEach( ( [ width, options ] ) => {\n      this.Style.rule( ' ', 'max-width', unit( options.width ), width );\n    } );\n  }\n\n  /**\n   * Registers styles for the track element.\n   */\n  private registerTrackStyles(): void {\n    const { Style } = this;\n    const selector = `.${ CLASS_TRACK }`;\n\n    this.breakpoints.forEach( ( [ width, options ] ) => {\n      Style.rule( selector, this.resolve( 'paddingLeft' ), this.cssPadding( options, false ), width );\n      Style.rule( selector, this.resolve( 'paddingRight' ), this.cssPadding( options, true ), width );\n      Style.rule( selector, 'height', this.cssTrackHeight( options ), width );\n    } );\n  }\n\n  /**\n   * Registers styles for the list element.\n   */\n  private registerListStyles(): void {\n    const { Style } = this;\n    const selector = `.${ CLASS_LIST }`;\n\n    this.breakpoints.forEach( ( [ width, options ] ) => {\n      Style.rule( selector, 'transform', this.buildTranslate( options ), width );\n\n      if ( ! this.cssSlideHeight( options ) ) {\n        Style.rule( selector, 'aspect-ratio', this.cssAspectRatio( options ), width );\n      }\n    } );\n  }\n\n  /**\n   * Registers styles for slides and clones.\n   */\n  private registerSlideStyles(): void {\n    const { Style } = this;\n    const selector = `.${ CLASS_SLIDE }`;\n\n    this.breakpoints.forEach( ( [ width, options ] ) => {\n      Style.rule( selector, 'width', this.cssSlideWidth( options ), width );\n      Style.rule( selector, 'height', this.cssSlideHeight( options ) || '100%', width );\n      Style.rule( selector, this.resolve( 'marginRight' ), unit( options.gap ) || '0px', width );\n      Style.rule( `${ selector } > img`, 'display', options.cover ? 'none' : 'inline', width );\n    } );\n  }\n\n  /**\n   * Builds multiple `translateX` for the list element.\n   *\n   * @param options - Options for each breakpoint.\n   *\n   * @return A string with multiple translate functions.\n   */\n  private buildTranslate( options: Options ): string {\n    const { resolve, orient } = this.Direction;\n    const values = [];\n\n    values.push( this.cssOffsetClones( options ) );\n    values.push( this.cssOffsetGaps( options ) );\n\n    if ( this.isCenter( options ) ) {\n      values.push( this.buildCssValue( orient( -50 ), '%' ) );\n      values.push( ...this.cssOffsetCenter( options ) );\n    }\n\n    return values\n      .filter( Boolean )\n      .map( value => `translate${ resolve( 'X' ) }(${ value })` )\n      .join( ' ' );\n  }\n\n  /**\n   * Returns offset for the list element.\n   * This does not include gaps because it can not be converted into percent.\n   *\n   * @param options - Options for each breakpoint.\n   *\n   * @return The offset.\n   */\n  private cssOffsetClones( options: Options ): string {\n    const { resolve, orient } = this.Direction;\n    const cloneCount = this.getCloneCount();\n\n    if ( this.isFixedWidth( options ) ) {\n      const { value, unit } = this.parseCssValue( options[ resolve( 'fixedWidth' ) ] );\n      return this.buildCssValue( orient( value ) * cloneCount, unit );\n    }\n\n    const percent = 100 * cloneCount / options.perPage;\n    return `${ orient( percent ) }%`;\n  }\n\n  /**\n   * Returns offset for centering the active slide.\n   *\n   * Note:\n   * ( 100% + gap ) / perPage - gap\n   * 100% / perPage + gap / perPage - gap;\n   * 50% / perPage + ( gap / perPage - gap ) / 2;\n   *\n   * @param options - Options for each breakpoint.\n   *\n   * @return The offset.\n   */\n  private cssOffsetCenter( options: Options ): string[] {\n    const { resolve, orient } = this.Direction;\n\n    if ( this.isFixedWidth( options ) ) {\n      const { value, unit } = this.parseCssValue( options[ resolve( 'fixedWidth' ) ] );\n      return [ this.buildCssValue( orient( value / 2 ), unit ) ];\n    }\n\n    const values = [];\n    const { perPage, gap } = options;\n\n    values.push( `${ orient( 50 / perPage ) }%` );\n\n    if ( gap ) {\n      const { value, unit } = this.parseCssValue( gap );\n      const gapOffset = ( value / perPage - value ) / 2;\n      values.push( this.buildCssValue( orient( gapOffset ), unit ) );\n    }\n\n    return values;\n  }\n\n  /**\n   * Returns offset for gaps.\n   *\n   * @param options - Options for each breakpoint.\n   *\n   * @return The offset as `calc()`.\n   */\n  private cssOffsetGaps( options: Options ): string {\n    const cloneCount = this.getCloneCount();\n\n    if ( cloneCount && options.gap ) {\n      const { orient } = this.Direction;\n      const { value, unit } = this.parseCssValue( options.gap );\n\n      if ( this.isFixedWidth( options ) ) {\n        return this.buildCssValue( orient( value * cloneCount ), unit );\n      }\n\n      const { perPage } = options;\n      const gaps = cloneCount / perPage;\n      return this.buildCssValue( orient( gaps * value ), unit );\n    }\n\n    return '';\n  }\n\n  /**\n   * Resolves the prop for the current direction and converts it into the Kebab case.\n   *\n   * @param prop - A property name to resolve.\n   *\n   * @return A resolved property name in the Kebab case.\n   */\n  private resolve( prop: string ): string {\n    return camelToKebab( this.Direction.resolve( prop ) );\n  }\n\n  /**\n   * Returns padding in the CSS format.\n   *\n   * @param options - Options.\n   * @param right   - Determines whether to get padding right or left.\n   *\n   * @return Padding in the CSS format.\n   */\n  private cssPadding( options: Options, right: boolean ): string {\n    const { padding } = options;\n    const prop = this.Direction.resolve( right ? 'right' : 'left', true );\n    return padding && unit( padding[ prop ] || ( isObject( padding ) ? 0 : padding ) ) || '0px';\n  }\n\n  /**\n   * Returns height of the track element in the CSS format.\n   *\n   * @param options - Options.\n   *\n   * @return Height in the CSS format.\n   */\n  private cssTrackHeight( options: Options ): string {\n    let height = '';\n\n    if ( this.isVertical() ) {\n      height = this.cssHeight( options );\n      assert( height, '\"height\" is missing.' );\n      height = `calc(${ height } - ${ this.cssPadding( options, false ) } - ${ this.cssPadding( options, true ) })`;\n    }\n\n    return height;\n  }\n\n  /**\n   * Returns height provided though options in the CSS format.\n   *\n   * @param options - Options.\n   *\n   * @return Height in the CSS format.\n   */\n  private cssHeight( options: Options ): string {\n    return unit( options.height );\n  }\n\n  /**\n   * Returns width of each slide in the CSS format.\n   *\n   * @param options - Options.\n   *\n   * @return Width in the CSS format.\n   */\n  private cssSlideWidth( options: Options ): string {\n    return options.autoWidth\n      ? ''\n      : unit( options.fixedWidth ) || ( this.isVertical() ? '' : this.cssSlideSize( options ) );\n  }\n\n  /**\n   * Returns height of each slide in the CSS format.\n   *\n   * @param options - Options.\n   *\n   * @return Height in the CSS format.\n   */\n  private cssSlideHeight( options: Options ): string {\n    return unit( options.fixedHeight )\n      || ( this.isVertical()\n        ? ( options.autoHeight ? '' : this.cssSlideSize( options ) )\n        : this.cssHeight( options )\n      );\n  }\n\n  /**\n   * Returns width or height of each slide in the CSS format, considering the current direction.\n   *\n   * @param options - Options.\n   *\n   * @return Width or height in the CSS format.\n   */\n  private cssSlideSize( options: Options ): string {\n    const gap = unit( options.gap );\n    return `calc((100%${ gap && ` + ${ gap }` })/${ options.perPage || 1 }${ gap && ` - ${ gap }` })`;\n  }\n\n  /**\n   * Returns the aspectRatio value to simulate the `heightRatio` option.\n   *\n   * @param options - Options.\n   *\n   * @return aspectRatio in the CSS format.\n   */\n  private cssAspectRatio( options: Options ): string {\n    const { heightRatio } = options;\n    return heightRatio ? `${ 1 / heightRatio }` : '';\n  }\n\n  /**\n   * Builds the css value by the provided value and unit.\n   *\n   * @param value - A value.\n   * @param unit  - A CSS unit.\n   *\n   * @return A built value for a CSS value.\n   */\n  private buildCssValue( value: number, unit: string ): string {\n    return `${ value }${ unit }`;\n  }\n\n  /**\n   * Parses the CSS value into number and unit.\n   *\n   * @param value - A value to parse.\n   *\n   * @return An object with value and unit.\n   */\n  private parseCssValue( value: string | number ): { value: number, unit: string } {\n    if ( isString( value ) ) {\n      const number = parseFloat( value ) || 0;\n      const unit   = value.replace( /\\d*(\\.\\d*)?/, '' ) || 'px';\n      return { value: number, unit };\n    }\n\n    return { value, unit: 'px' };\n  }\n\n  /**\n   * Parses breakpoints and generate options for each breakpoint.\n   */\n  private parseBreakpoints(): void {\n    const { breakpoints } = this.options;\n\n    this.breakpoints.push( [ 'default', this.options ] );\n\n    if ( breakpoints ) {\n      forOwn( breakpoints, ( options, width ) => {\n        this.breakpoints.push( [ width, merge( merge( {}, this.options ), options ) ] );\n      } );\n    }\n  }\n\n  /**\n   * Checks if the slide width is fixed or not.\n   *\n   * @return `true` if the slide width is fixed, or otherwise `false`.\n   */\n  private isFixedWidth( options: Options ): boolean {\n    return !! options[ this.Direction.resolve( 'fixedWidth' ) ];\n  }\n\n  /**\n   * Checks if the slider type is loop or not.\n   *\n   * @return `true` if the slider type is loop, or otherwise `false`.\n   */\n  private isLoop(): boolean {\n    return this.options.type === LOOP;\n  }\n\n  /**\n   * Checks if the active slide should be centered or not.\n   *\n   * @return `true` if the slide should be centered, or otherwise `false`.\n   */\n  private isCenter( options: Options ): boolean {\n    if( options.focus === 'center' ) {\n      if ( this.isLoop() ) {\n        return true;\n      }\n\n      if ( this.options.type === SLIDE ) {\n        return ! this.options.trimSpace;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if the direction is TTB or not.\n   *\n   * @return `true` if the direction is TTB, or otherwise `false`.\n   */\n  private isVertical(): boolean {\n    return this.options.direction === TTB;\n  }\n\n  /**\n   * Builds classes of the root element.\n   *\n   * @return Classes for the root element as a single string.\n   */\n  private buildClasses(): string {\n    const { options } = this;\n\n    return [\n      CLASS_ROOT,\n      `${ CLASS_ROOT }--${ options.type }`,\n      `${ CLASS_ROOT }--${ options.direction }`,\n      options.drag && `${ CLASS_ROOT }--draggable`,\n      options.isNavigation && `${ CLASS_ROOT }--nav`,\n      CLASS_ACTIVE,\n      ! this.config.hidden && CLASS_RENDERED,\n    ].filter( Boolean ).join( ' ' );\n  }\n\n  /**\n   * Converts provided attributes into a single string.\n   *\n   * @param attrs - An object with attributes.\n   *\n   * @return A built string.\n   */\n  private buildAttrs( attrs: Record<string, string | number | boolean> ): string {\n    let attr = '';\n\n    forOwn( attrs, ( value, key ) => {\n      attr += value ? ` ${ camelToKebab( key ) }=\"${ value }\"` : '';\n    } );\n\n    return attr.trim();\n  }\n\n  /**\n   * Converts provided styles into a single string.\n   *\n   * @param styles - An object with styles.\n   *\n   * @return A built string.\n   */\n  private buildStyles( styles: Record<string, string | number> ): string {\n    let style = '';\n\n    forOwn( styles, ( value, key ) => {\n      style += ` ${ camelToKebab( key ) }:${ value };`;\n    } );\n\n    return style.trim();\n  }\n\n  /**\n   * Generates HTML of slides with inserting provided contents.\n   *\n   * @return The HTML for all slides and clones.\n   */\n  private renderSlides(): string {\n    const { slideTag: tag } = this.config;\n\n    return this.slides.map( content => {\n      return `<${ tag } ${ this.buildAttrs( content.attrs ) }>${ content.html || '' }</${ tag }>`;\n    } ).join( '' );\n  }\n\n  /**\n   * Add the `background` style for the cover mode.\n   *\n   * @param content - A slide content.\n   */\n  private cover( content: SlideContent ): void {\n    const { styles, html = '' } = content;\n\n    if ( this.options.cover && ! this.options.lazyLoad ) {\n      const src = html.match( /<img.*?src\\s*=\\s*(['\"])(.+?)\\1.*?>/ );\n\n      if ( src && src[ 2 ] ) {\n        styles.background = `center/cover no-repeat url('${ src[ 2 ] }')`;\n      }\n    }\n  }\n\n  /**\n   * Generates clones.\n   *\n   * @param contents - An array with SlideContent objects.\n   */\n  private generateClones( contents: SlideContent[] ): void {\n    const { classes } = this.options;\n    const count  = this.getCloneCount();\n    const slides = contents.slice();\n\n    while ( slides.length < count ) {\n      push( slides, slides );\n    }\n\n    push( slides.slice( -count ).reverse(), slides.slice( 0, count ) ).forEach( ( content, index ) => {\n      const attrs = assign( {}, content.attrs, { class: `${ content.attrs.class } ${ classes.clone }` } );\n      const clone = assign( {}, content, { attrs } );\n      index < count ? contents.unshift( clone ) : contents.push( clone );\n    } );\n  }\n\n  /**\n   * Returns the number of clones to generate.\n   *\n   * @return A number of clones.\n   */\n  private getCloneCount(): number {\n    if ( this.isLoop() ) {\n      const { options } = this;\n\n      if ( options.clones ) {\n        return options.clones;\n      }\n\n      const perPage = max( ...this.breakpoints.map( ( [ , options ] ) => options.perPage ) );\n      return perPage * ( ( options.flickMaxPages || 1 ) + 1 );\n    }\n\n    return 0;\n  }\n\n  /**\n   * Generates arrows and the wrapper element.\n   *\n   * @return The HTML for arrows.\n   */\n  private renderArrows(): string {\n    let html = '';\n\n    html += `<div class=\"${ this.options.classes.arrows }\">`;\n    html += this.renderArrow( true );\n    html += this.renderArrow( false );\n    html += `</div>`;\n\n    return html;\n  }\n\n  /**\n   * Generates an arrow HTML.\n   * Some attributes are temporary, and Splide changes them after mount.\n   *\n   * @param prev - Options for each breakpoint.\n   *\n   * @return The HTML for the prev or next arrow.\n   */\n  private renderArrow( prev: boolean ): string {\n    const { classes, i18n } = this.options;\n    const attrs = {\n      class    : `${ classes.arrow } ${ prev ? classes.prev : classes.next }`,\n      type     : 'button',\n      ariaLabel: prev ? i18n.prev : i18n.next,\n    };\n\n    return `<button ${ this.buildAttrs( attrs ) }>`\n      +\t`<svg xmlns=\"${ XML_NAME_SPACE }\" viewBox=\"0 0 ${ SIZE } ${ SIZE }\" width=\"${ SIZE }\" height=\"${ SIZE }\">`\n      + `<path d=\"${ this.options.arrowPath || PATH }\" />`\n      + `</svg>`\n      + `</button>`;\n  }\n\n  /**\n   * Returns the HTML of the slider.\n   *\n   * @return The generated HTML.\n   */\n  html(): string {\n    const { rootClass, listTag, arrows, beforeTrack, afterTrack, slider, beforeSlider, afterSlider } = this.config;\n\n    let html = '';\n\n    html += `<div id=\"${ this.id }\" class=\"${ this.buildClasses() } ${ rootClass || '' }\">`;\n    html += `<style>${ this.Style.build() }</style>`;\n\n    if ( slider ) {\n      html += beforeSlider || '';\n      html += `<div class=\"splide__slider\">`;\n    }\n\n    html += beforeTrack || '';\n\n    if ( arrows ) {\n      html += this.renderArrows();\n    }\n\n    html += `<div class=\"splide__track\">`;\n    html += `<${ listTag } class=\"splide__list\">`;\n\n    html += this.renderSlides();\n\n    html += `</${ listTag }>`;\n    html += `</div>`; // .track\n\n    html += afterTrack || '';\n\n    if ( slider ) {\n      html += `</div>`;\n      html += afterSlider || '';\n    }\n\n    html += `</div>`; // .splide\n\n    return html;\n  }\n}\n","/**\n * Pads the number with 0.\n *\n * @param number - A number to pad.\n *\n * @return string - Padded number.\n */\nexport function pad( number: number ): string {\n  return number < 10 ? `0${ number }` : `${ number }`;\n}\n","import { slice } from '../../arrayLike';\n\n\n/**\n * Returns elements that match the provided selector.\n *\n * @param parent   - A parent element to start searching from.\n * @param selector - A selector to query.\n *\n * @return An array with matched elements.\n */\nexport function queryAll<E extends Element = Element>( parent: Element | Document, selector: string ): E[] {\n  return slice<E>( parent.querySelectorAll( selector ) );\n}\n","/**\n * The type for the regular slider.\n *\n * @since 3.0.0\n */\nexport const SLIDE = 'slide';\n\n/**\n * The type for the carousel slider.\n *\n * @since 3.0.0\n */\nexport const LOOP = 'loop';\n\n/**\n * The type for the fade slider that can not have multiple slides in a page.\n *\n * @since 3.0.0\n */\nexport const FADE = 'fade';\n","export const CLASS_RENDERED = 'is-rendered';\n","/**\n * The namespace for SVG elements.\n */\nexport const XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\n\n/**\n * The arrow path.\n */\nexport const PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\n\n/**\n * SVG width and height.\n */\nexport const SIZE = 40;\n"],"names":["RTL","TTB","ORIENTATION_MAP","marginRight","autoWidth","fixedWidth","paddingLeft","paddingRight","width","left","right","x","X","Y","ArrowLeft","ArrowRight","Direction","Splide2","Components2","options","resolve","prop","axisOnly","direction","orient","value","PROJECT_CODE","CLASS_ROOT","CLASS_TRACK","CLASS_LIST","CLASS_SLIDE","CLASS_CLONE","CLASS_ARROW","CLASS_PAGINATION","CLASS_ACTIVE","DEFAULTS","type","role","speed","waitForTransition","perPage","cloneStatus","arrows","pagination","interval","pauseOnHover","pauseOnFocus","resetProgress","keyboard","easing","drag","slideFocus","trimSpace","focusableNodes","classes","slide","clone","arrow","prev","next","page","spinner","i18n","first","last","slideX","pageX","play","pause","carousel","slideLabel","isObject","subject","isArray","Array","isString","toArray","forEach","values","iteratee","push","array","items","arrayProto","prototype","slice","arrayLike","start","end","call","matches","elm","selector","HTMLElement","child","parent","children","filter","firstElementChild","forOwn","object","keys","Object","reverse","i","length","key","assign","arguments","source","merge","remove","nodes","node","parentNode","removeChild","unit","assert","condition","message","Error","Math","min","max","floor","ceil","abs","camelToKebab","string","replace","toLowerCase","ids","EventInterface","event","listeners","unbind","targets","events","callback","forEachEvent","target","event2","listener","removeEventListener","split","func","bind","apply","destroy","data","offBy","on","priority","off","emit","addEventListener","RENDERER_DEFAULT_CONFIG","listTag","slideTag","Style","id","styles","rule","breakpoint","selectors","this","build","css","default","buildSelectors","sort","n","m","_this","mediaQuery","_this2","trim","contents","config","defaults","slides","breakpoints","prefix","number","init","clean","splide","root","clones","querySelectorAll","parseBreakpoints","initSlides","registerRootStyles","registerTrackStyles","registerSlideStyles","registerListStyles","map","content","index","html","attrs","_this3","cover","class","style","buildStyles","isLoop","generateClones","_this4","Style2","_this5","cssPadding","cssTrackHeight","_this6","buildTranslate","cssSlideHeight","cssAspectRatio","_this7","cssSlideWidth","gap","cssOffsetClones","cssOffsetGaps","isCenter","buildCssValue","cssOffsetCenter","Boolean","join","cloneCount","getCloneCount","isFixedWidth","parseCssValue","unit2","padding","height","isVertical","cssHeight","cssSlideSize","fixedHeight","autoHeight","heightRatio","parseFloat","_this8","focus","buildClasses","isNavigation","hidden","buildAttrs","attr","renderSlides","tag","_this9","lazyLoad","src","match","background","count","unshift","flickMaxPages","renderArrows","renderArrow","ariaLabel","arrowPath","rootClass","beforeTrack","afterTrack","slider","beforeSlider","afterSlider"],"mappings":"kPACaA,EAAM,MACNC,EAAM,MCDNC,EAAkB,CAC7BC,YAAa,CAAC,eAAgB,cAC9BC,UAAW,CAAC,cACZC,WAAY,CAAC,eACbC,YAAa,CAAC,aAAc,gBAC5BC,aAAc,CAAC,gBAAiB,eAChCC,MAAO,CAAC,UACRC,KAAM,CAAC,MAAO,SACdC,MAAO,CAAC,SAAU,QAClBC,EAAG,CAAC,KACJC,EAAG,CAAC,KACJC,EAAG,CAAC,KACJC,UAAW,CAAC,UAAW,cACvBC,WAAY,CAAC,YAAa,uBAEZC,EAAUC,EAASC,EAAaC,SASvC,CACLC,iBATeC,EAAMC,OACbC,EAAcJ,EAAdI,iBAEDrB,EAAgBmB,GADTE,IAAcvB,GAAQsB,EAAeC,IAActB,EAAM,GAAK,EAA7B,IACRoB,GAOvCG,gBALcC,UACPA,GAASN,EAAQI,YAAcvB,EAAM,GAAK,SCvBxC0B,EAAe,YCCfC,EAAaD,EAEbE,EAAiBF,YACjBG,EAAgBH,WAChBI,EAAiBJ,YACjBK,EAAiBD,YAGjBE,EAAiBN,YAGjBO,EAAsBP,iBAUtBQ,EAAe,YCpBfC,EAAW,CACtBC,KAAM,QACNC,KAAM,SACNC,MAAO,IACPC,mBAAmB,EACnBC,QAAS,EACTC,aAAa,EACbC,QAAQ,EACRC,YAAY,EACZC,SAAU,IACVC,cAAc,EACdC,cAAc,EACdC,eAAe,EACfC,UAAU,EACVC,OAAQ,gCACRC,MAAM,EACN3B,UAAW,MACX4B,YAAY,EACZC,WAAW,EACXC,eAAgB,6CAChBC,QDMqB,CACrBC,MAAOzB,EACP0B,MAAOzB,EACPW,OAvB6BhB,aAwB7B+B,MAAOzB,EACP0B,KAvBiC1B,WAwBjC2B,KAvBiC3B,WAwBjCW,WAAYV,EACZ2B,KAvBsC3B,WAwBtC4B,QAlB8BnC,eCI9BoC,KCvBkB,CAClBJ,KAAM,iBACNC,KAAM,aACNI,MAAO,oBACPC,KAAM,mBACNC,OAAQ,iBACRC,MAAO,gBACPC,KAAM,iBACNC,MAAO,iBACPC,SAAU,WACVd,MAAO,QACPe,WAAY,sBCXEC,EAASC,UAgBJ,OAfJA,GAA+B,iBAAZA,WAEpBC,EAAQD,UACfE,MAAMD,QAAQD,YAKPG,EAASH,SACG,iBAAZA,WCTAI,EAAQnD,UACfgD,EAAQhD,GAASA,EAAQ,CAACA,YCDnBoD,EAAQC,EAAQC,GAC9BH,EAAQE,GAAQD,QAAQE,YCDVC,EAAKC,EAAOC,UAC1BD,EAAMD,WAANC,EAAcL,EAAQM,IACfD,MCEIE,EAAaT,MAAMU,mBCJhBC,EAAMC,EAAWC,EAAOC,UAC/BL,EAAWE,MAAMI,KAAKH,EAAWC,EAAOC,YCDjCE,EAAQC,EAAKC,UACND,aNiBKE,cMjBIF,EAAG,mBAAyBA,EAAID,SAASD,KAAKE,EAAKC,YCDnEE,EAAMC,EAAQH,UACrBA,GCAwBA,EDAIA,ICAZG,EDAIA,GCCXV,EAAMU,EAAOC,UAAUC,OAAO,SAACH,UAAUJ,EAAQI,EAAOF,KAAa,IDDxC,IAAKG,EAAOG,sBCA1BN,WCFjBO,EAAOC,EAAQrB,EAAUrE,MACnC0F,UACEC,EAAOC,OAAOD,KAAKD,GACvBC,EAAO3F,EAAQ2F,EAAKE,UAAYF,EACvBG,EAAI,EAAGA,EAAIH,EAAKI,OAAQD,IAAK,KAC9BE,EAAML,EAAKG,MACL,cAARE,IACiC,IAA/B3B,EAASqB,EAAOM,GAAMA,gBAMzBN,WCXOO,EAAOP,UACrBf,EAAMuB,UAAW,GAAG/B,QAAQ,SAACgC,GAC3BV,EAAOU,EAAQ,SAACpF,EAAOiF,GACrBN,EAAOM,GAAOG,EAAOH,OAGlBN,WCNOU,EAAMV,EAAQS,UAC5BV,EAAOU,EAAQ,SAACpF,EAAOiF,GACjBjC,EAAQhD,GACV2E,EAAOM,GAAOjF,EAAM4D,QACXd,EAAS9C,GAClB2E,EAAOM,GAAOI,EAAMvC,EAAS6B,EAAOM,IAAQN,EAAOM,GAAO,GAAIjF,GAE9D2E,EAAOM,GAAOjF,IAGX2E,WCXOW,EAAOC,GACrBnC,EAAQmC,EAAO,SAACC,GACVA,GAAQA,EAAKC,YACfD,EAAKC,WAAWC,YAAYF,cCHlBG,EAAK3F,UACZkD,EAASlD,GAASA,EAAQA,EAAWA,OAAY,YCD1C4F,EAAOC,EAAWC,OAC3BD,QACG,IAAIE,UAAU9F,QAAiB6F,GAAW,KCHNE,KAA/BC,QAAKC,EAA0BF,KAA1BE,IAA0BF,KAArBG,MAAqBH,KAAdI,KAAcJ,KAARK,aCAtBC,EAAaC,UACpBA,EAAOC,QAAQ,qBAAsB,SAASC,kBCAjDC,EAAM,YCCIC,EAAenH,OACrBoH,EAAUpH,EAAVoH,MACF3B,EAAM,GACR4B,EAAY,YAaPC,EAAOC,EAASC,EAAQC,GAC/BC,EAAaH,EAASC,EAAQ,SAACG,EAAQC,GACrCP,EAAYA,EAAUrC,OAAO,SAAC6C,YACxBA,EAAS,KAAOF,GAAUE,EAAS,KAAOD,GAAYH,GAAYI,EAAS,KAAOJ,KACpFE,EAAOG,oBAAoBF,EAAQC,EAAS,GAAIA,EAAS,KAClD,gBAMNH,EAAaH,EAASC,EAAQ1D,GACrCF,EAAQ2D,EAAS,SAACI,GACZA,GACFH,EAAOO,MAAM,KAAKnE,iBC/BJoE,UACbA,EAAKC,WAALD,GAAU,aAAS5D,EAAMuB,UAAW,KD8BXuC,CAAMpE,EAAU6D,eAIvCQ,IACPd,EAAYA,EAAUrC,OAAO,SAACoD,UAASd,EAAOc,EAAK,GAAIA,EAAK,MAC5DhB,EAAMiB,MAAM5C,UAEd2B,EAAMkB,GEnBqB,UFmBHH,EAAS1C,GAC1B,CACL6C,YApCUd,EAAQC,EAAUc,GAC5BnB,EAAMkB,GAAGd,EAAQC,EAAUhC,EAAK8C,IAoChCC,aAlCWhB,GACXJ,EAAMoB,IAAIhB,EAAQ/B,IAkClBgD,KAAMrB,EAAMqB,KACZR,cAjCYV,EAASC,EAAQC,EAAUvH,GACvCwH,EAAaH,EAASC,EAAQ,SAACG,EAAQC,GACrCP,EAAUtD,KAAK,CAAC4D,EAAQC,EAAQH,EAAUvH,IAC1CyH,EAAOe,iBAAiBd,EAAQH,EAAUvH,MA+B5CoH,OAAAA,EACAa,QAAAA,OG/CSQ,EAA0B,CACrCC,QAAS,KACTC,SAAU,MCDCC,wBACCC,EAAI7I,QACT8I,OAAS,QACTD,GAAKA,OACL7I,QAAUA,6BAEjB+I,KAAA,SAAKtE,EAAUvE,EAAMI,EAAO0I,GAEpBC,EAAYC,KAAKJ,OADvBE,EAAaA,GAAc,WACiBE,KAAKJ,OAAOE,IAAe,IACxDC,EAAUxE,GAAYwE,EAAUxE,IAAa,IACrDvE,GAAQI,KAEjB6I,MAAA,sBACMC,EAAM,UACNF,KAAKJ,OAAOO,UACdD,GAAOF,KAAKI,eAAeJ,KAAKJ,OAAOO,UAEzClE,OAAOD,KAAKgE,KAAKJ,QAAQS,KAAK,SAACC,EAAGC,SAAkC,QAA5BC,EAAK1J,QAAQ2J,YAAwBH,GAAKC,GAAKA,GAAKD,IAAG9F,QAAQ,SAACsF,GACnF,YAAfA,IACFI,oCAAwCJ,UACxCI,GAAOM,EAAKJ,eAAeI,EAAKZ,OAAOE,IACvCI,UAGGA,KAETE,eAAA,SAAeL,cACTG,EAAM,UACVpE,EAAOiE,EAAW,SAACH,EAAQrE,GACzBA,OAAemF,EAAKf,OAAMpE,GAAWoF,OACrCT,GAAU3E,OACVO,EAAO8D,EAAQ,SAACxI,EAAOJ,IACjBI,GAAmB,IAAVA,IACX8I,GAAUlJ,OAASI,SAGvB8I,GAAO,MAEFA,qCCXGU,EAAU9J,EAAS+J,EAAQC,QAChCC,OAAS,QACTjK,QAAU,QACVkK,YAAc,GACnBvE,EAAM3E,EAAUgJ,GAAY,IAC5BrE,EAAMA,EAAMuD,KAAKlJ,QAASgB,GAAWhB,GAAW,SAC3C8J,SAAWA,OACXC,OAASvE,EAAO,GAAIiD,EAAyBsB,GAAU,SACvDlB,GAAKK,KAAKa,OAAOlB,QNlCDsB,EMkCgB,YCpCrBC,EPGKpD,EAAImD,IAAWnD,EAAImD,IAAW,GAAK,GOF1C,OAASC,KAAcA,QDoChCxB,MAAQ,IAAIA,EAAMM,KAAKL,GAAIK,KAAKlJ,cAChCH,UAAYA,EAAU,EAAM,EAAMqJ,KAAKlJ,SAC5CkG,EAAOgD,KAAKY,SAASxE,OAAQ,oCACxB+E,SAEAC,MAAP,SAAaC,OACHnC,EAAOnB,EAAesD,GAAtBnC,GACAoC,EAASD,EAATC,KACFC,GE5CuBhG,MF4CK7D,EE3C7BsD,EF2CmBsG,EE3CNE,iBAAiBjG,KF4CnC2D,EH9CyB,UG8CP,WAChBxC,EAAOjB,EAAM6F,EAAM,YAErB5E,EAAO6E,+BAETJ,KAAA,gBACOM,wBACAC,kBACAC,0BACAC,2BACAC,2BACAC,wBAEPJ,WAAA,sBACE/G,EAAKqF,KAAKe,OAAQf,KAAKY,SAASmB,IAAI,SAACC,EAASC,IAC5CD,EAAU1H,EAAS0H,GAAW,CAAEE,KAAMF,GAAYA,GAC1CpC,OAASoC,EAAQpC,QAAU,GACnCoC,EAAQG,MAAQH,EAAQG,OAAS,GACjCC,EAAKC,MAAML,GACL/I,EAAamJ,EAAKtL,QAAQmC,QAAQC,WAAmB,IAAV+I,EAAcpK,EAAe,WAC9EyE,EAAO0F,EAAQG,MAAO,CACpBG,OAAUrJ,OAAW+I,EAAQG,MAAMG,OAAS,KAAK3B,OACjD4B,MAAOH,EAAKI,YAAYR,EAAQpC,UAE3BoC,KAELhC,KAAKyC,eACFC,eAAe1C,KAAKe,WAG7BY,mBAAA,2BACOX,YAAYxG,QAAQ,gBAAErE,OAAOW,OAChC6L,EAAKjD,MAAMG,KAAK,IAAK,YAAa9C,EAAKjG,EAAQX,OAAQA,QAG3DyL,oBAAA,sBACiBgB,EAAW5C,KAAlBN,MACFnE,MAAehE,OAChByJ,YAAYxG,QAAQ,gBAAErE,OAAOW,OAChC8L,EAAO/C,KAAKtE,EAAUsH,EAAK9L,QAAQ,eAAgB8L,EAAKC,WAAWhM,GAAS,GAAQX,GACpFyM,EAAO/C,KAAKtE,EAAUsH,EAAK9L,QAAQ,gBAAiB8L,EAAKC,WAAWhM,GAAS,GAAOX,GACpFyM,EAAO/C,KAAKtE,EAAU,SAAUsH,EAAKE,eAAejM,GAAUX,QAGlE2L,mBAAA,sBACiBc,EAAW5C,KAAlBN,MACFnE,MAAe/D,OAChBwJ,YAAYxG,QAAQ,gBAAErE,OAAOW,OAChC8L,EAAO/C,KAAKtE,EAAU,YAAayH,EAAKC,eAAenM,GAAUX,GAC5D6M,EAAKE,eAAepM,IACvB8L,EAAO/C,KAAKtE,EAAU,eAAgByH,EAAKG,eAAerM,GAAUX,QAI1E0L,oBAAA,sBACiBe,EAAW5C,KAAlBN,MACFnE,MAAe9D,OAChBuJ,YAAYxG,QAAQ,gBAAErE,OAAOW,OAChC8L,EAAO/C,KAAKtE,EAAU,QAAS6H,EAAKC,cAAcvM,GAAUX,GAC5DyM,EAAO/C,KAAKtE,EAAU,SAAU6H,EAAKF,eAAepM,IAAY,OAAQX,GACxEyM,EAAO/C,KAAKtE,EAAU6H,EAAKrM,QAAQ,eAAgBgG,EAAKjG,EAAQwM,MAAQ,MAAOnN,GAC/EyM,EAAO/C,KAAQtE,WAAkB,UAAWzE,EAAQuL,MAAQ,OAAS,SAAUlM,QAGnF8M,eAAA,SAAenM,SACekJ,KAAKrJ,UAAzBI,IAAAA,QAASI,IAAAA,OACXsD,EAAS,UACfA,EAAOE,KAAKqF,KAAKuD,gBAAgBzM,IACjC2D,EAAOE,KAAKqF,KAAKwD,cAAc1M,IAC3BkJ,KAAKyD,SAAS3M,KAChB2D,EAAOE,KAAKqF,KAAK0D,cAAcvM,GAAQ,IAAK,MAC5CsD,EAAOE,WAAPF,EAAeuF,KAAK2D,gBAAgB7M,KAE/B2D,EAAOmB,OAAOgI,SAAS7B,IAAI,SAAC3K,qBAAsBL,EAAQ,SAAQK,QAAUyM,KAAK,QAE1FN,gBAAA,SAAgBzM,SACckJ,KAAKrJ,UAAzBI,IAAAA,QAASI,IAAAA,OACX2M,EAAa9D,KAAK+D,mBACpB/D,KAAKgE,aAAalN,GAAU,GACCkJ,KAAKiE,cAAcnN,EAAQC,EAAQ,gBAA1DK,IAAAA,MAAa8M,IAANnH,YACRiD,KAAK0D,cAAcvM,EAAOC,GAAS0M,EAAYI,UAG9C/M,EADM,IAAM2M,EAAahN,EAAQqB,gBAG7CwL,gBAAA,SAAgB7M,SACckJ,KAAKrJ,UAAzBI,IAAAA,QAASI,IAAAA,UACb6I,KAAKgE,aAAalN,GAAU,OACCkJ,KAAKiE,cAAcnN,EAAQC,EAAQ,gBAA1DK,IAAAA,MAAa8M,IAANnH,WACR,CAACiD,KAAK0D,cAAcvM,EAAOC,EAAQ,GAAI8M,QAE1CzJ,EAAS,GACPtC,EAAiBrB,EAAjBqB,QAASmL,EAAQxM,EAARwM,WACjB7I,EAAOE,KAAQxD,EAAO,GAAKgB,QACvBmL,IACMlM,KAAuB4I,KAAKiE,cAAcX,IAA1ClM,MAAa8M,IAANnH,KAEftC,EAAOE,KAAKqF,KAAK0D,cAAcvM,GADZC,EAAQe,EAAUf,GAAS,GACI8M,KAE7CzJ,KAET+I,cAAA,SAAc1M,OACNgN,EAAa9D,KAAK+D,mBACpBD,GAAchN,EAAQwM,IAAK,KACrBnM,EAAW6I,KAAKrJ,UAAhBQ,SACuB6I,KAAKiE,cAAcnN,EAAQwM,KAAlDlM,IAAAA,MAAa8M,IAANnH,QACXiD,KAAKgE,aAAalN,UACbkJ,KAAK0D,cAAcvM,EAAOC,EAAQ0M,GAAaI,GAEhD/L,EAAYrB,EAAZqB,eAED6H,KAAK0D,cAAcvM,EADb2M,EAAa3L,EACcf,GAAQ8M,SAE3C,MAETnN,QAAA,SAAQC,UACC0G,EAAasC,KAAKrJ,UAAUI,QAAQC,OAE7C8L,WAAA,SAAWhM,EAAST,GACV8N,EAAYrN,EAAZqN,QACFnN,EAAOgJ,KAAKrJ,UAAUI,QAAQV,EAAQ,QAAU,QAAQ,UACvD8N,GAAWpH,EAAKoH,EAAQnN,KAAUkD,EAASiK,GAAW,EAAIA,KAAa,SAEhFpB,eAAA,SAAejM,OACTsN,EAAS,UACTpE,KAAKqE,eAEPrH,EADAoH,EAASpE,KAAKsE,UAAUxN,GACT,wBACfsN,UAAiBA,QAAYpE,KAAK8C,WAAWhM,GAAS,SAAYkJ,KAAK8C,WAAWhM,GAAS,QAEtFsN,KAETE,UAAA,SAAUxN,UACDiG,EAAKjG,EAAQsN,WAEtBf,cAAA,SAAcvM,UACLA,EAAQf,UAAY,GAAKgH,EAAKjG,EAAQd,cAAgBgK,KAAKqE,aAAe,GAAKrE,KAAKuE,aAAazN,OAE1GoM,eAAA,SAAepM,UACNiG,EAAKjG,EAAQ0N,eAAiBxE,KAAKqE,aAAevN,EAAQ2N,WAAa,GAAKzE,KAAKuE,aAAazN,GAAWkJ,KAAKsE,UAAUxN,OAEjIyN,aAAA,SAAazN,OACLwM,EAAMvG,EAAKjG,EAAQwM,yBACLA,SAAaA,SAAUxM,EAAQqB,SAAW,IAAImL,SAAaA,UAEjFH,eAAA,SAAerM,GACL4N,EAAgB5N,EAAhB4N,mBACDA,KAAiB,EAAIA,EAAgB,MAE9ChB,cAAA,SAActM,EAAO8M,YACT9M,EAAQ8M,KAEpBD,cAAA,SAAc7M,UACRkD,EAASlD,GAGJ,CAAEA,MAFMuN,WAAWvN,IAAU,EAEZ2F,KADV3F,EAAMwG,QAAQ,cAAe,KAAO,MAG7C,CAAExG,MAAAA,EAAO2F,KAAM,SAExB0E,iBAAA,sBACUT,EAAgBhB,KAAKlJ,QAArBkK,iBACHA,YAAYrG,KAAK,CAAC,UAAWqF,KAAKlJ,UACnCkK,GACFlF,EAAOkF,EAAa,SAAClK,EAASX,GAC5ByO,EAAK5D,YAAYrG,KAAK,CAACxE,EAAOsG,EAAMA,EAAM,GAAImI,EAAK9N,SAAUA,UAInEkN,aAAA,SAAalN,WACFA,EAAQkJ,KAAKrJ,UAAUI,QAAQ,kBAE1C0L,OAAA,iBGzNkB,SH0NTzC,KAAKlJ,QAAQiB,QAEtB0L,SAAA,SAAS3M,MACe,WAAlBA,EAAQ+N,MAAoB,IAC1B7E,KAAKyC,gBACA,KGhOM,UHkOXzC,KAAKlJ,QAAQiB,YACPiI,KAAKlJ,QAAQiC,iBAGlB,KAETsL,WAAA,kBACSrE,KAAKlJ,QAAQI,YAActB,KAEpCkP,aAAA,eACUhO,EAAYkJ,KAAZlJ,cACD,CACLQ,EACGA,OAAeR,EAAQiB,KACvBT,OAAeR,EAAQI,UAC1BJ,EAAQ+B,MAAWvB,gBACnBR,EAAQiO,cAAmBzN,UAC3BO,GACCmI,KAAKa,OAAOmE,QIpPW,eJqPxBpJ,OAAOgI,SAASC,KAAK,QAEzBoB,WAAA,SAAW9C,OACL+C,EAAO,UACXpJ,EAAOqG,EAAO,SAAC/K,EAAOiF,GACpB6I,GAAQ9N,MAAYsG,EAAarB,QAASjF,MAAW,KAEhD8N,EAAKvE,UAEd6B,YAAA,SAAY5C,OACN2C,EAAQ,UACZzG,EAAO8D,EAAQ,SAACxI,EAAOiF,GACrBkG,OAAa7E,EAAarB,OAAQjF,QAE7BmL,EAAM5B,UAEfwE,aAAA,sBACoBC,EAAQpF,KAAKa,OAAvBpB,gBACDO,KAAKe,OAAOgB,IAAI,SAACC,aACXoD,MAAOC,EAAKJ,WAAWjD,EAAQG,YAAUH,EAAQE,MAAQ,SAAOkD,QAC1EvB,KAAK,OAEVxB,MAAA,SAAML,OACIpC,EAAsBoC,EAAtBpC,SAAsBoC,EAAdE,KAAAA,aAAO,MACnBlC,KAAKlJ,QAAQuL,OAAUrC,KAAKlJ,QAAQwO,WAChCC,EAAMrD,EAAKsD,MAAM,wCACZD,EAAI,KACb3F,EAAO6F,0CAA4CF,EAAI,YAI7D7C,eAAA,SAAe9B,WACL3H,EAAY+G,KAAKlJ,QAAjBmC,QACFyM,EAAQ1F,KAAK+D,gBACbhD,EAASH,EAAS5F,QACjB+F,EAAO3E,OAASsJ,GACrB/K,EAAKoG,EAAQA,GAEfpG,EAAKoG,EAAO/F,OAAO0K,GAAOxJ,UAAW6E,EAAO/F,MAAM,EAAG0K,IAAQlL,QAAQ,SAACwH,EAASC,OACvEE,EAAQ7F,EAAO,GAAI0F,EAAQG,MAAO,CAAEG,MAAUN,EAAQG,MAAMG,UAASrJ,EAAQE,QAC7EA,EAAQmD,EAAO,GAAI0F,EAAS,CAAEG,MAAAA,IACpCF,EAAQyD,EAAQ9E,EAAS+E,QAAQxM,GAASyH,EAASjG,KAAKxB,QAG5D4K,cAAA,cACM/D,KAAKyC,SAAU,KACT3L,EAAYkJ,KAAZlJ,eACJA,EAAQyK,OACHzK,EAAQyK,OAEDjE,eAAO0C,KAAKgB,YAAYe,IAAI,wBAA2B5J,aACpDrB,EAAQ8O,eAAiB,GAAK,UAE5C,KAETC,aAAA,eACM3D,EAAO,UACXA,kBAAuBlC,KAAKlJ,QAAQmC,QAAQZ,YAC5C6J,GAAQlC,KAAK8F,aAAY,GACzB5D,GAAQlC,KAAK8F,aAAY,GACzB5D,eAGF4D,YAAA,SAAYzM,SACgB2G,KAAKlJ,QAAvBmC,IAAAA,QAASQ,IAAAA,KACX0I,EAAQ,CACZG,MAAUrJ,EAAQG,WAASC,EAAOJ,EAAQI,KAAOJ,EAAQK,MACzDvB,KAAM,SACNgO,UAAW1M,EAAOI,EAAKJ,KAAOI,EAAKH,uBAEnB0G,KAAKiF,WAAW9C,oGAAiHnC,KAAKlJ,QAAQkP,WK1ThJ,kHL4TlB9D,KAAA,iBACqGlC,KAAKa,OAAhGoF,IAAAA,UAAWzG,IAAAA,QAASnH,IAAAA,OAAQ6N,IAAAA,YAAaC,IAAAA,WAAYC,IAAAA,OAAQC,IAAAA,aAAcC,IAAAA,YAC/EpE,EAAO,UACXA,eAAoBlC,KAAKL,eAAcK,KAAK8E,oBAAkBmB,GAAa,SAC3E/D,aAAkBlC,KAAKN,MAAMO,mBACzBmG,IACFlE,GAAQmE,GAAgB,GACxBnE,mCAEFA,GAAQgE,GAAe,GACnB7N,IACF6J,GAAQlC,KAAK6F,gBAEf3D,iCACAA,OAAY1C,2BACZ0C,GAAQlC,KAAKmF,eACbjD,QAAa1C,MACb0C,YACAA,GAAQiE,GAAc,GAClBC,IACFlE,YACAA,GAAQoE,GAAe,IAEzBpE"}